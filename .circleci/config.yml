version: 2.1

# Definindo jobs para build, teste e deploy
jobs:
  test-go:
    # Instala módulos Go e executa testes
    docker:
      - image: cimg/go:1.20
    steps:
      - checkout
      - restore_cache:
          key: go-mod-{{ checksum "go.sum" }}
      - run:
          name: Download Go modules
          command: go mod download
      - run:
          name: Print go mod help instructions
          command: |
            echo "go mod download will fail if you have private repositories 
            One way to fix this for private go modules that are hosted in github:
              1. Add a GITHUB_TOKEN and GITHUB_USER to an org context. Please refer to https://circleci.com/docs/contexts/ for more information on how to use contexts.
              2. Add a .circleci/config.yml to your repository or use this config.yml as a starting template.
              3. Configure the jobs to use the newly created context which includes GITHUB_TOKEN and GITHUB_USER.
              4. Before downloading the modules you will need to add a step to execute \"go env -w GOPRIVATE=github.com/<OrgNameHere>\". 
              This allows go mod to install private repos under OrgNameHere.
              5. You will also need to run \"git config --global url.\"https://$GITHUB_USER:$GITHUB_TOKEN@github.com/<OrgNameHere>/\".insteadOf \"https://github.com/<OrgNameHere>/\".
              6. Finally include the \"go mod download\" it should be able to fetch your private libraries now. 
            For gitlab private go modules, follow the same instructions as above but include your GITLAB_TOKEN and GITLAB_USER.
            Then use gitlab.com instead of github.com in steps 4 and 5.
            See https://go.dev/ref/mod#private-modules for more details."
          when: on_fail
      - save_cache:
          key: go-mod-{{ checksum "go.sum" }}
          paths:
            - /home/circleci/go/pkg/mod
      - run:
          name: Run tests
          command: gotestsum --junitfile junit.xml
      - store_test_results:
          path: junit.xml

  build-go-executables:
    # Compila executáveis Go e armazena como artefatos
    docker:
      - image: cimg/go:1.20
    steps:
      - checkout
      - restore_cache:
          key: go-mod-{{ checksum "go.sum" }}
      - run:
          name: Download Go modules
          command: go mod download
      - save_cache:
          key: go-mod-{{ checksum "go.sum" }}
          paths:
            - /home/circleci/go/pkg/mod
      - run:
          name: Create the ~/artifacts directory if it doesn't exist
          command: mkdir -p ~/artifacts
      - run:
          name: Build executables
          command: go build -o ~/artifacts ./...
      - store_artifacts:
          path: ~/artifacts
          destination: executables

  deploy:
    # Realiza o deploy da aplicação no Railway
    docker:
      - image: cimg/go:1.20
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Install Railway CLI
          command: curl -fsSL https://railway.app/install.sh | sh
      - run:
          name: Login to Railway
          # Usa a variável de ambiente $RAILWAY_TOKEN para autenticar a CLI do Railway
          command: echo $RAILWAY_TOKEN | railway login --ci
      - run:
          name: Deploy to Railway
          # Com o login feito, executa o deploy da aplicação no Railway
          command: railway up --service my-go-app

# Workflow para coordenar os jobs
workflows:
  version: 2
  build-and-test:
    jobs:
      - test-go
      - build-go-executables:
          requires:
            - test-go
      - deploy:
          requires:
            - build-go-executables
